# SimpleDocker:

----------------------------------------------------------------------------

- [SimpleDocker:](#SimpleDocker)
    - [1. Готовый докер:](#1-готовый-докер)
    - [2. Операции с контейнером:](#2-операции-с-контейнером)
    - [3. Мини веб-сервер:](#3-мини-веб-сервер)
    - [4. Свой докер:](#4-свой-докер)
    - [5. Dockle:](#5-dockle)
    - [6. Базовый Docker Compose:](#6-базовый-docker-compose)

----------------------------------------------------------------------------

## 1. Готовый докер:
- Установил **docker** и **docker desktop** на **ОС Windows 11 v. 23H2**.

> Версия **docker**:
>
> ![Версия](screen%2Fscreen_1_01.png)
>

- Выкачал официальный докер-образ с **nginx** при помощи команды `docker pull nginx`.

> Скачивание докер-образа с **nginx**:
>
> ![Скачивание докер-образа с nginx](screen%2Fscreen_1_02.png)
>

- Проверил наличие докер-образа через команду `docker images`.

> Список скачанных докер-образов:
>
> ![Список скачанных докер-образов](screen%2Fscreen_1_03.png)
>

- Запустил докер-образ командой `docker run -d [IMAGE_ID]`.

> Запуск докер-образа:
>
> ![Запуск докер-образа](screen%2Fscreen_1_04.png)
>

- Проверил запуск образа командой `docker ps`.

> Список запущенных контейнеров:
>
> ![Список запущенных контейнеров](screen%2Fscreen_1_05.png)
>

- Отобразил информацию о контейнере командой `docker inspect [CONTAINER_ID]`.

> Вывод информации о контейнере:
>
> ![Информация о контейнере](screen%2Fscreen_1_06.png)
>

- Описание контейнера:
  - размер контейнера: 64 MB
  - замапленый порт: 80
  - ip контейнера: 172.17.0.2

> Размер контейнера (shared memory):
>
> ![Размер контейнера](screen%2Fscreen_1_07.png)
>
> Значение **"ShmSize"** составляет **67,108,864 байт**, что эквивалентно **64 MB**. Это стандартный размер по умолчанию для Docker-контейнеров.
> 

> Замапленый порт:
>
> ![Замапленый порт](screen%2Fscreen_1_08.png)
>
> **Замапленный (от англ. "mapped") порт** который сопоставлен с портом на хост-машине (той, на которой запущен Docker). Процесс маппинга позволяет перенаправить сетевой трафик с определенного порта хост-машины на соответствующий порт внутри контейнера.
> 

> ip контейнера:
>
> ![ip контейнера](screen%2Fscreen_1_09.png)
>
> **172.17.0.2** — это уникальный адрес данного контейнера внутри сети **Docker**.
> 

- Остановил докер контейнер командой `docker stop [CONTAINER_ID]`.
- Поверил, что контейнер остановился командой `docker ps`

> Остановка контейнера:
>
> ![Остановка контейнер](screen%2Fscreen_1_10.png)
>

- Запустил докер с портами **80** и **443** в контейнере, замапленными на такие же порты на локальной машине командой `docker run -d -p 80:80 -p 443:443 nginx`.
- Проверил запуск образа командой `docker ps`.

> Успешный запуск контейнера с портами 80 и 443:
>
> ![Успешный запуск контейнера с портами 80 и 443](screen%2Fscreen_1_11.png)
>

- Перешёл в браузере по адресу **localhost:80**.

> Стартовая страница **nginx**:
>
> ![Стартовая страница nginx](screen%2Fscreen_1_12.png)
>

- Перезапустил докер контейнер командой `docker restart [CONTAINER_ID]`.
- Проверил перезапуск контейнера командой `docker ps`.

> Успешный перезапуск контейнера:
>
> ![Успешный перезапуск контейнера](screen%2Fscreen_1_13.png)
>

----------------------------------------------------------------------------

## 2. Операции с контейнером:

- Отобразил конфигурационный файл `nginx.conf` внутри докер контейнера с помощью команды `docker exec -it [CONTAINER_ID] cat /etc/nginx/nginx.conf`.

> Конфигурационный файл nginx.conf:
>
> ![Конфигурационный файл nginx.conf](screen%2Fscreen_2_01.png)
>
> `docker exec` : используется для выполнения команды внутри запущенного Docker-контейнера.
>
> `-i` (interactive): означает, что команда должна работать в интерактивном режиме.
>
> `-t` (tty): создает терминал для взаимодействия.
> 

```nginx
user  nginx;  # Пользователь, от имени которого будут запущены процессы Nginx.
worker_processes  auto;  # Количество процессов рабочих Nginx. "auto" означает, что Nginx автоматически выберет оптимальное число рабочих процессов (обычно равно числу ядер процессора).

error_log  /var/log/nginx/error.log notice;  # Путь к файлу журнала ошибок и уровень логирования (здесь "notice" — логирование уведомлений).
pid        /var/run/nginx.pid;  # Путь к файлу с PID (идентификатор процесса) основного процесса Nginx.

events {
    worker_connections  1024;  # Максимальное количество одновременных соединений, которые каждый процесс-работник может обрабатывать.
}

http {
    include       /etc/nginx/mime.types;  # Подключает файл с типами MIME для определения типа контента.
    default_type  application/octet-stream;  # Тип контента по умолчанию, если не удалось определить MIME-тип (octet-stream используется для бинарных файлов).

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';  # Определяет формат записи журнала доступа. Каждый запрос логируется с информацией о клиенте, запросе, статусе и др.

    access_log  /var/log/nginx/access.log  main;  # Путь к файлу журнала доступа с использованием формата "main", описанного выше.

    sendfile        on;  # Включает использование системной функции sendfile(), что ускоряет передачу файлов через сеть.
    #tcp_nopush     on;  # Комментарий: эта опция может использоваться для оптимизации передачи данных, но она выключена по умолчанию.

    keepalive_timeout  65;  # Время (в секундах), в течение которого соединение будет поддерживаться открытым для последующих запросов.

    #gzip  on;  # Комментарий: эта строка включает сжатие Gzip для уменьшения объема передаваемых данных, но оно отключено по умолчанию.

    include /etc/nginx/conf.d/*.conf;  # Включает все конфигурационные файлы из директории "/etc/nginx/conf.d/". Обычно это виртуальные хосты и дополнительные настройки.
}
```

- Создал файл `nginx.conf` на хостовой машине, скопировав туда изначальные настройки конфигурации и добавив в него параметры отдачи страницы статуса сервера **nginx** по пути `/status`.

> Модифицированный файл `nginx.conf`:
>
> ![Модифицированный файл nginx.conf](screen%2Fscreen_2_02.png)
>

```nginx
# Добавленые строки
    server {
        listen 80;  # Установка порта для прослушивания запросов
        server_name localhost;  # Имя сервера (можно заменить на свой домен или IP)

        location /status {
           stub_status on;  # Включение страницы статуса Nginx.
           allow all;  # Разрешение доступа ко всем на страницу статуса.
       }
   }
}
```

- Скопировал файл конфигурации `nginx.conf` внутрь докер контейнера, командой `docker cp ./nginx.conf [CONTAINER_ID]:/etc/nginx/nginx.conf`.

> Копирование файла `nginx.conf`:
>
> ![Копирование файла nginx.conf](screen%2Fscreen_2_03.png)
>

- Перезапустил сервер **nginx** внутри докер контейнера командой `docker exec -it [CONTAINER_ID] nginx -s reload`.

> Перезапуск сервера **nginx**:
>
> Флаг `-s` позволяет применить новые настройки без остановки самого процесса nginx.
> 
> ![Перезапуск сервера nginx](screen%2Fscreen_2_04.png)
>
> Сообщение об ошибке предупреждает, что есть конфликты с именем сервера `localhost`, так как оно уже используется на порту `0.0.0.0:80`. Это значит, что в конфигурации **nginx** уже существует другой сервер, который прослушивает этот порт с таким же именем.
> 

- Проверил наличие других конфигурационных файлов **nginx** внутри докер контейнера командами `docker exec -it [CONTAINER_ID] ls /etc/nginx/` и `docker exec -it [CONTAINER_ID] ls /etc/nginx/conf.d`.

> Директория с файлами конфигурации **nginx**:
>
> ![Директория с файлами конфигурации nginx](screen%2Fscreen_2_05.png)
>

- Отобразил дефолтный конфигурационный файл **nginx** `default.conf`  с помощью команды `docker exec -it [CONTAINER_ID] cat /etc/nginx/conf.d/default.conf`.

> Дефолтный файл конфигурации **nginx**:
>
> ![Дефолтный файл конфигурации nginx](screen%2Fscreen_2_06.png)
>
> Из вывода видно, что по умолчанию конфигурация **nginx** в контейнере уже прослушивает порт `80` и использует `server_name localhost`. Это и вызывает конфликт при попытке загрузить другую конфигурацию на тот же порт и серверное имя.
>

- Удалил конфигурационный файл `default.conf`  с помощью команды `docker exec -it [CONTAINER_ID] rm /etc/nginx/conf.d/default.conf`.

> Удаление файла `default.conf`:
>
> ![Удаление файла default.conf](screen%2Fscreen_2_07.png)
>

- Перезапустил сервер **nginx** внутри докер контейнера командой `docker exec -it [CONTAINER_ID] nginx -s reload`.

> Перезапуск сервера **nginx**:
>
> ![Перезапуск сервера nginx](screen%2Fscreen_2_08.png)
>

- Перешёл в браузере по адресу **localhost:80/status**.

> Страничка со статусом сервера **nginx**:
>
> ![Страничка со статусом сервера nginx](screen%2Fscreen_2_09.png)
>

- Экспортировал контейнер в файл `container.tar` командой `docker export [CONTAINER_ID] -o container.tar`.

> Экспортирование контейнера в файл:
>
> ![Экспортирование контейнера в файл](screen%2Fscreen_2_10.png)
>

- Остановил контейнер командой `docker stop [CONTAINER_ID]`.

> Остановка контейнера:
>
> ![Остановка контейнера](screen%2Fscreen_2_11.png)
>

- Удалил образ командой `docker rmi -f [IMAGE_ID]`, не удаляя перед этим контейнеры.

> Удаление образа:
>
> ![Удаление образа](screen%2Fscreen_2_12.png)
>
> Флаг `-f` позволит принудительно удалить образ. Без него система не даст удалить образ, при существующем остановленным контейнером, который использует этот образ.
>

- Проверил, что образ удалился командой `docker images`.

> Список доступных докер-образов:
>
> ![Список доступных докер-образов](screen%2Fscreen_2_13.png)
>

- Удалил докер контейнер командой `docker rm [CONTAINER_ID]`.

> Удаление докер контейнера:
>
> ![Удаление докер контейнера](screen%2Fscreen_2_14.png)
>

- Проверил, что контейнер удалился командой `docker ps -a`.

> Список всех докер контейнеров:
>
> ![Список всех докер контейнеров](screen%2Fscreen_2_15.png)
>
> Флаг `-a` отображает остановленные контейнеры.
> 

- Импортировал контейнер обратно командой `docker import container.tar [NEW_NAME_IMAGE]`.
- Проверил, что контейнер импортировался командой `docker images`.

> Импортирование контейнера:
>
> ![Импортирование контейнера](screen%2Fscreen_2_16.png)
>

- Попробовал запустить импортированный контейнер командой `docker run -d -p 80:80 -p 443:443 [IMAGE_ID]`.

> Запуск импортированного контейнера:
>
> ![Запуск импортированного контейнера](screen%2Fscreen_2_17.png)
>
> Ошибка `no command specified` возникает, потому что при создании образа с помощью команды `docker import`, **docker** не сохраняет команду, которую необходимо выполнить по умолчанию при запуске контейнера.
> 
> Официальный образ **nginx** уже настроен для работы "из коробки". В нём заранее указана команда для запуска **nginx** при создании контейнера, поэтому, когда запускается контейнер с официальным образом, он сразу стартует веб-сервер **nginx** без дополнительных указаний.
> 
> **Импортированный образ** (который мы создали через `docker import`) не содержит данных о том, какую команду выполнять при старте контейнера.
>

- Запустил импортированный контейнер, явно указав команду, которую контейнер должен выполнить `docker run -d -p 80:80 -p 443:443 8e1e9b36c054 nginx -g 'daemon off;'`.
- Проверил запуск контейнера командой `docker ps`.

> Успешный запуск импортированного контейнера:
>
> ![Успешный запуск импортированного контейнера](screen%2Fscreen_2_18.png)
>
> Флаг `-g` : используется для передачи глобальных директив напрямую в конфигурацию **nginx** из командной строки.
> 
> `'daemon off;'` : отключает работу **nginx** в фоновом режиме (демонизацию) и говорит работать на переднем плане, что требуется для контейнера **docker**.
>

- Проверил, что по адресу **localhost:80/status** отдается страничка со статусом сервера **nginx**.

> Страничка со статусом сервера **nginx**:
>
> ![Страничка со статусом сервера nginx](screen%2Fscreen_2_19.png)
>

----------------------------------------------------------------------------

## 3. Мини веб-сервер:
- Написал мини-сервер на **C** и **FastCgi**, который будет возвращать страничку с надписью **Hello World!**.

> **mini_server.c**:
>
> ![Мини-сервер с использованием FastCgi](screen%2Fscreen_3_01.png)
>

```c
#include <fcgiapp.h>  // Подключаем библиотеку для работы с FastCGI
#include <stdio.h>    // Подключаем стандартную библиотеку для работы с вводом/выводом

int main(void) {
  FCGX_Init();  // Инициализируем FastCGI библиотеку
  FCGX_Request request;  // Создаем объект запроса FastCGI

  // Инициализируем запрос и привязываем его к стандартному входу (0)
  // FCGI_FAIL_ACCEPT_ON_INTR означает, что функция вернет ошибку, если запрос прервется
  if (FCGX_InitRequest(&request, 0, FCGI_FAIL_ACCEPT_ON_INTR) != 0) {
    return 1;  // Возвращаем 1, если инициализация запроса не удалась
  }

  // Бесконечный цикл, который обрабатывает входящие FastCGI-запросы
  while (FCGX_Accept_r(&request) == 0) {
    // Отправляем заголовок HTTP-ответа, указывая тип содержимого (text/html)
    FCGX_FPrintF(request.out, "Content-type: text/html\r\n");
    FCGX_FPrintF(request.out, "\r\n");  // Отправляем пустую строку, завершая заголовки

    // Начинаем HTML-ответ
    FCGX_FPrintF(request.out, "<html>\n");
    FCGX_FPrintF(request.out, "<head>\n");
    FCGX_FPrintF(request.out, "<title>Hello World!</title>\n");  // Указываем заголовок страницы
    FCGX_FPrintF(request.out, "</head>\n");

    // Создаем тело HTML-страницы с заголовком "Hello World!"
    FCGX_FPrintF(request.out, "<body>\n");
    FCGX_FPrintF(request.out, "<h1><center>Hello World!</center></h1>\n");  // Центрированный заголовок
    FCGX_FPrintF(request.out, "</body>\n");

    // Закрываем HTML-тег
    FCGX_FPrintF(request.out, "</html>\n");

    // Завершаем обработку текущего запроса
    FCGX_Finish_r(&request);
  }
  
  return 0;
}
```

- Запустил контейнер на основе официального докер-образа **nginx**, с замапленным портом 81 и с именем **onionyas_server**, командой `docker run -d --name onionyas_server -p 81:81 [IMAGE_ID]`.
- Проверил запуск контейнера командой `docker ps`.

> Успешный запуск контейнера:
>
> ![Успешный запуск контейнера](screen%2Fscreen_3_02.png)
>

- Вошел в работающий контейнер в интерактивном режиме, открыв **bash**-терминал командой `docker exec -it [CONTAINER_ID] bash`.

> Вход в интерактивный режим:
>
> ![Вход в интерактивный режим](screen%2Fscreen_3_03.png)
>

- Установил необходимые утилиты внутрь контейнера, которые помогут запустить и отладить написанный мини-сервер.


- **Список утилит и команд для установки:**
  - **gcc** : `apt install gcc`.
  - **vim** : `apt install vim`.
  - **lib fcgi** : `apt install libfcgi`.
  - **lib fcgiapp** :`apt install libfcgi-dev`.
  - **spawn-fcgi** `apt install spawn-fcgi`.
  - **netplan** : `apt install net-tools`.
  - **ps** : `apt install procps`.

<details><summary><strong>Процесс установки утилит.</strong></summary>

> ![Update](screen%2Fscreen_3_04.png)
> ![Установка gcc](screen%2Fscreen_3_05.png)
> ![Установка vim](screen%2Fscreen_3_06.png)
> ![Установка fcgi](screen%2Fscreen_3_07.png)
> ![Установка fcgiapp](screen%2Fscreen_3_08.png)
> ![Установка spawn-fcgi](screen%2Fscreen_3_09.png)
> ![Установка netplan](screen%2Fscreen_3_10.png)
> ![Установка ps](screen%2Fscreen_3_11.png)

</details>

- Создал директорию `server` внутри контейнера.

> Корневая директория контейнера:
>
> ![Корневая директория контейнера](screen%2Fscreen_3_12.png)
>

- Вышел из контейнера командой `exit`.
- Скопировал написанный мини-сервер в директорию `server` внутрь контейнера.

> Копирование `mini_server.c` внутрь контейнера:
>
> ![Копирование mini_server.c внутрь контейнера](screen%2Fscreen_3_13.png)
>

- Написал свой файл `nginx.conf`, который будет проксировать все запросы с `81` порта на `127.0.0.1:8080`.

> Написанный `nginx.conf`:
>
> ![Написанный nginx.conf](screen%2Fscreen_3_14.png)
>

```nginx
user  nginx;  # Указание пользователя, от имени которого Nginx будет запускать процессы (здесь это 'nginx').
worker_processes  auto;  # Автоматически настроить количество рабочих процессов в зависимости от доступных процессоров на системе.

error_log  /var/log/nginx/error.log warn;  # Путь к файлу журнала ошибок и уровень логирования (warn: предупреждения).
pid        /var/run/nginx.pid;  # Путь к файлу, содержащему PID (идентификатор процесса) Nginx.

events {
    worker_connections  1024;  # Количество максимальных соединений, которое каждый рабочий процесс может обслуживать одновременно.
}

http {
    include       /etc/nginx/mime.types;  # Включение файла с MIME-типами для определения типов контента по расширению файла.
    default_type  application/octet-stream;  # Тип содержимого по умолчанию, если MIME-тип не может быть определен (бинарные данные).

    sendfile        on;  # Включение отправки файлов с использованием системного вызова sendfile для повышения производительности.
    keepalive_timeout  65;  # Тайм-аут поддержания соединения в секундах (как долго Nginx будет держать соединение открытым для новых запросов).

    server {
        listen 81;  # Nginx будет прослушивать порт 81 для входящих соединений.
        server_name localhost;  # Имя сервера (домен или IP-адрес). Здесь 'localhost', что означает локальная машина.

        location / {  
            fastcgi_pass 127.0.0.1:8080;  # Все запросы на корень (/) будут проксированы на FastCGI-сервер, работающий на 127.0.0.1:8080.
            include fastcgi_params;  # Включение файла fastcgi_params для передачи стандартных параметров FastCGI (например, переменных среды).
        }
    }
}
```

- Скопировал написанный файл `nginx.conf` внутрь контейнера.

> Копирование `nginx.conf` внутрь контейнера:
>
> ![Копирование nginx.conf внутрь контейнера](screen%2Fscreen_3_15.png)
>

- Перешёл внутрь контейнера в директорию `server`, где лежит `mini_server.c`.
- Скомпилировал свой мини-сервер, указав имя `my_fcgi_mini_server`, командой `gcc -o my_fcgi_mini_server mini_server.c -lfcgi`.

> Компилирование программы:
>
> ![Компилирование программы](screen%2Fscreen_3_16.png)
>

- Запустил свой мини-сервер через **spawn-fcgi**, который будет прослушивать только локальные соединения по адресу `127.0.0.1` и порту `8080`, командой `spawn-fcgi -a 127.0.0.1 -p 8080 ./my_fcgi_mini_server`.
- Проверил запуск процесса командой `ps aux`.
- Проверил работу процесса на заданном **ip** и **порту** командой `netstat -tulnp`.

> Успешный запуск мини-сервера:
>
> ![Успешный запуск мини-сервера](screen%2Fscreen_3_17.png)
>

- Перезапустил сервер **nginx** внутри докер контейнера командой `nginx -s reload`.

> Перезапуск сервера **nginx**:
>
> ![Перезапуск сервера nginx](screen%2Fscreen_3_18.png)
>

- Перешёл в браузере по адресу **localhost:81**.

> Успешно отданная страница:
>
> ![Успешно отданная страница](screen%2Fscreen_3_19.png)
>

<details><summary><strong>Описание процесса получения страницы.</strong></summary>

**Когда мы переходим в браузере по адресу `localhost:81`, браузер отправляет HTTP-запрос на `nginx`, который прослушивает порт `81` согласно нашей конфигурации.**

- Ожидаемое поведение:
  - **nginx** получает запрос на порт `81` : наша конфигурация **nginx** настроена так, что все запросы, поступающие на этот порт, проксируются на **fastCGI-сервер**, работающий на `127.0.0.1:8080`.
  - **nginx** перенаправляет запрос **fastCGI-серверу** : **nginx** направляет запрос **fastCGI-приложению** (нашему мини серверу), который отвечает на порту `8080` на том же хосте (`127.0.0.1`).
  - **fastCGI-сервер** обрабатывает запрос : наше **fastCGI-приложение** (`my_fcgi_mini_server`) обрабатывает запрос и возвращает **HTML-ответ**. Согласно нашему коду, **fastCGI-сервер** вернет простой **HTML**, который содержит заголовок и сообщение **"Hello World!"** на странице.
  - **nginx** отправляет результат клиенту (браузеру) : **nginx** получает ответ от **fastCGI-приложения** и отправляет его обратно клиенту, то есть нашему браузеру.
</details>

- Положил файл `nginx.conf` по пути `./nginx/nginx.conf` для дальнейшего использования.

> Копирование `nginx.conf`:
>
> ![Копирование nginx.conf](screen%2Fscreen_3_20.png)
>

----------------------------------------------------------------------------

## 4. Свой докер:
- Написал свой докер-образ:

```dockerfile
# Первый этап: Компиляция mini_server
FROM gcc:latest AS builder

# Скопируем файл mini_server.c в контейнер
COPY server/mini_server.c /mini_server.c

# Устанавливаем необходимые библиотеки для FastCGI и компилируем mini_server в одном RUN
RUN apt-get update && \
    apt-get install -y libfcgi-dev && \
    gcc -o my_fcgi_mini_server /mini_server.c -lfcgi

# Второй этап: Настройка контейнера с Nginx и FastCGI сервером
FROM nginx:latest

# Устанавливаем spawn-fcgi и libfcgi и создаем директорию "server"
RUN apt-get update && \
    apt-get install -y spawn-fcgi libfcgi && \
    mkdir "server"

# Копируем скомпилированный сервер из предыдущего этапа
COPY --from=builder /my_fcgi_mini_server /server/my_fcgi_mini_server

# Копируем конфигурационный файл nginx
COPY ./nginx/nginx.conf /etc/nginx/nginx.conf

# Запускаем написанный мини-сервер через spawn-fcgi на порту 8080 и включаем nginx на переднем плане
CMD ["sh", "-c", "spawn-fcgi -a 127.0.0.1 -p 8080 /server/my_fcgi_mini_server && nginx -g 'daemon off;'"]
```
- Собрал написанный докер-образ указав имя `my_fastcgi_server` и тег `v1.0` командой `docker build -t my_fastcgi_server:v1.0 .`.
- Проверил наличие собранного докер-образа командой `docker images`.

> Сборка докер-образа:
>
> ![Сборка докер-образ](screen%2Fscreen_4_01.png)
>

- Запустил собранный докер-образ указав имя контейнера `onionyas_server`, с маппингом `81` порта на `80` на хостовой машине и маппингом файла `./nginx/nginx.conf` внутрь контейнера по адресу, где лежит конфигурационный файл `nginx.conf` командой `docker run -d --name onionyas_server -p 80:81 -v ${PWD}/nginx/nginx.conf:/etc/nginx/nginx.conf my_fastcgi_server:v1.0`.
- Проверил запуск контейнера командой `docker ps`.

> Запуск контейнера:
>
> ![Запуск контейнера](screen%2Fscreen_4_02.png)
>

- Проверил, что по адресу `localhost:80` доступна страничка написанного мини сервера.

> Страница по адресу `localhost:80` в браузере:
>
> ![Страница по адресу localhost:80 в браузере](screen%2Fscreen_4_03.png)
>

- Дописал в `./nginx/nginx.conf` проксирование странички `/status`.

> Измененный файл `nginx.conf`:
>
> ![Измененный файл nginx.conf](screen%2Fscreen_4_04.png)
>

- Перезапустил докер контейнер командой `docker restart [CONTAINER_NAME]`.

> Перезапуск докер контейнера:
>
> ![Перезапуск докер контейнера](screen%2Fscreen_4_05.png)
>

- Проверил, что по адресу `localhost:80/status` отдается страничка со статусом **nginx**.

> Страница по адресу `localhost:80/status` в браузере:
>
> ![Страница по адресу localhost:80/status в браузере](screen%2Fscreen_4_06.png)
>

----------------------------------------------------------------------------

## 5. Dockle:
- Запустил `wsl` и установил на него утилиту `dockle`.
- Просканировал образ из предыдущего задания командой `dockle my_fastcgi_server:v1.0`.

> Вывод команды `dockle my_fastcgi_server:v1.0`:
>
> ![Вывод команды dockle my_fastcgi_server:v1.0](screen%2Fscreen_5_01.png)
>

**Сообщения от Dockle показывают несколько предупреждений и ошибок безопасности:**:

<details><summary><strong>FATAL ошибки:</strong></summary>

- `CIS-DI-0010` : **Do not store credential in environment variables/files** (Не храните учетные данные в переменных окружения/файлах).

  Переменная `NGINX_GPGKEYS` хранит ключи `GPG` в `ENV`, что небезопасно.
- `DKL-DI-0005` : **Clear apt-get caches** (Очистите кэш apt-get).

  После установки пакетов через `apt-get install` не очищен кэш. Это увеличивает размер образа.

</details>

<details><summary><strong>WARN предупреждения:</strong></summary>

- `CIS-DI-0001` : **Create a user for the container** (Создайте пользователя для контейнера).

  В данный момент все команды выполняются от имени пользователя `root`.

</details>

<details><summary><strong>INFO предупреждения:</strong></summary>

- `CIS-DI-0005` : **Enable Content trust for Docker** (Включите Content Trust для Docker).
<br><br>
- `CIS-DI-0006` : **Add HEALTHCHECK instruction to the container image** (Добавьте инструкцию `HEALTHCHECK`).
<br><br>
- `CIS-DI-0008`: **Confirm safety of setuid/setgid files** (Подтвердите безопасность `setuid/setgid` файлов).

</details>

- Исправил `dockerfile`:.

```dockerfile
# Первый этап: Компиляция mini_server
FROM gcc:latest AS builder

# Скопируем файл mini_server.c в контейнер
COPY server/mini_server.c /mini_server.c

# Устанавливаем необходимые библиотеки для FastCGI и компилируем mini_server в одном RUN
RUN apt-get update && \
    apt-get install -y libfcgi-dev && \
    gcc -o my_fcgi_mini_server /mini_server.c -lfcgi

# Второй этап: Настройка контейнера с Nginx и FastCGI сервером
FROM nginx:latest

# Устанавливаем необходимые пакеты и настраиваем права от имени root
RUN apt-get update && apt-get install -y gcc spawn-fcgi libfcgi-dev && \
    chown -R nginx:nginx /etc/nginx/nginx.conf && \
    chown -R nginx:nginx /var/cache/nginx && \
    touch /var/run/nginx.pid && \
    chown -R nginx:nginx /var/run/nginx.pid; \
    chmod u-s /usr/bin/passwd /usr/bin/su /usr/bin/gpasswd && \
    chmod u-s /usr/bin/newgrp /usr/bin/chsh /usr/bin/umount /usr/bin/mount && \
    chmod u-s /usr/bin/chfn && \
    chmod g-s /usr/bin/expiry /usr/bin/chage /usr/sbin/unix_chkpwd && \
    rm -rf /var/lib/apt/lists

# Копируем скомпилированный сервер из предыдущего этапа
COPY --from=builder /my_fcgi_mini_server /server/my_fcgi_mini_server

# Копируем конфигурационный файл nginx
COPY ./nginx/nginx.conf /etc/nginx/nginx.conf

# Устанавливаем права на запуск сервера
RUN chmod +x /server/my_fcgi_mini_server && chown nginx:nginx /server/my_fcgi_mini_server

# Переключаемся на пользователя nginx
USER nginx

# Включаем Content Trust для Docker
ENV DOCKER_CONTENT_TRUST=1

# Добовляем инструкцию HEALTHCHECK для проверки состояния сервера
HEALTHCHECK NONE

# Запускаем написанный мини-сервер через spawn-fcgi на порту 8080 и включаем nginx на переднем плане
CMD ["sh", "-c", "spawn-fcgi -a 127.0.0.1 -p 8080 /server/my_fcgi_mini_server && nginx -g 'daemon off;'"]
```

- Собрал исправленный докер-образ указав имя `my_fastcgi_server` и тег `v2.0` командой `docker build -t my_fastcgi_server:v2.0 .`.

> Сборка исправленного докер-образа:
>
> ![Сборка исправленного докер-образа](screen%2Fscreen_5_02.png)
>

- Просканировал образ командой ` dockle -ak NGINX_GPGKEY_PATH -ak NGINX_GPGKEY my_fastcgi_server:v2.0`.

*Аргументы `-ak` в `Dockle` используются для указания переменных окружения, которые нужно игнорировать при проверке безопасности образа. `-ak NGINX_GPGKEY_PATH` и `-ak NGINX_GPGKEY` указывает `Dockle` не обращать внимания на потенциальные проблемы, связанные с этими переменными.*

**Т.к. мы уверены, что хранение этих переменных в образе безопасно и не представляет угрозы безопасности.**

> Просканированный образ `my_fastcgi_server:v2.0` без ошибок:
>
> ![Просканированный образ my_fastcgi_server:v2.0 без ошибок](screen%2Fscreen_5_03.png)
>

----------------------------------------------------------------------------

## 6. Базовый Docker Compose:
- Написал файл `docker-compose.yml`, который поднимает докер-контейнер из [задания 5](#5-dockle) и докер-контейнер с **nginx** (с мапингом `8080` порта на `80` порт локальной машины):

```yml
version: '3.8'  # Версия Docker Compose, которая будет использоваться.

services:
  # Первый контейнер с FastCGI-сервером
  fastcgi_server:
    build:
      context: . 
      dockerfile: Dockerfile  # Указываем Dockerfile для сборки образа.
    container_name: onionyas_fcgi  # Имя контейнера.
    networks:
      - internal_network  # Контейнер будет подключен сети internal_network, для взаимодействия с другими контейнерами в этой сети.

  # Второй контейнер с Nginx, который проксирует запросы на FastCGI
  nginx_proxy:
    image: nginx:latest  # Используем официальный образ Nginx с Docker Hub (последняя версия).
    container_name: onionyas_nginx  # Имя контейнера
    networks:
      - internal_network  # Контейнер также подключен к той же сети internal_network, чтобы он мог отправлять запросы на `fastcgi_server`.
    ports:
      - "80:8080"  # Маппинг портов: внешний порт 80 на хост-машине перенаправляется на порт 8080 внутри контейнера Nginx.
    volumes:
      - ./part6/nginx/nginx.conf:/etc/nginx/nginx.conf  # Мапинг файла `nginx.conf` в контейнер.
    depends_on:
      - fastcgi_server  # Гарантируем, что контейнер `nginx_proxy` не начнет работу до тех пор, пока контейнер `fastcgi_server` не будет готов.
    command: ["nginx", "-g", "daemon off;"]  # Включаем nginx на переднем плане.
    extra_hosts:
      - "localhost:host-gateway"  # Добавляем запись в файл `/etc/hosts`, которая позволяет контейнеру обращаться к хосту через `localhost`.

networks:
  internal_network:
    driver: bridge  # Определяем тип сети. В данном случае используется мостовая сеть (bridge), что создает изолированную сеть для взаимодействия контейнеров между собой.
```

- Написал `nginx.conf` для контейнера **nginx**, в котором указал проксировать все запросы с `8080` порта на `81` порт первого контейнера.


> Файл `part6/nginx/nginx.conf`:
>
> ![Файл part6/nginx/nginx.conf](screen%2Fscreen_6_01.png)
>

- Остановил все запущенные контейнеры, и проверив командой `docker ps`.
- Собрал проект командой `docker compose build`.

> Сборка проекта:
>
> ![Сборка проекта](screen%2Fscreen_6_02.png)
>

- Запустил проект командой `docker-compose up -d`.

*Флаг `-d` : запускает контейнеры в фоновом режиме.*

- Проверил запуск командой `docker-compose ps`.

> Запуск проекта:
>
> ![Запуск проекта](screen%2Fscreen_6_03.png)
>

- Проверил, что в браузере по пути `localhost:80` и `localhost:80/status` отдаются нужные страницы.


> Страница по адресу `localhost:80` в браузере:
>
> ![Страница по адресу localhost:80 в браузере](screen%2Fscreen_6_04.png)
>


> Страница по адресу `localhost:80/status` в браузере:
>
> ![Страница по адресу localhost:80/status в браузере](screen%2Fscreen_6_05.png)
>

----------------------------------------------------------------------------